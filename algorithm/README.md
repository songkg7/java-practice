# Algorithm

## 3장. [Linked Lists](src/main/java/linkedlists) (연결리스트)

### 왜 연결 리스트를 사용하는가?

우선 연결 리스트와 배열의 차이를 먼저 이해하는 것이 중요하다.

### 배열

배열의 항목에 접근하기 위해서는 항목의 주소가 배열의 기본 주소로부터의 오프셋으로 계산되고 한 번의 곱셈 연산으로 항목의 주소를 구하기 위해 기본 주소에 더해져야 할 값이
계산된다.
처음에 데이터형에 따른 항목의 크기가 계산되고, 그것이 항목의 인덱스에 곱해져서 기본 주소에 더해질 값이 된다.

이 과정에 한 번의 곱셈과 한 번의 덧셈이 필요하다. 이 두 연산이 일정한 시간이 걸리므로 배열 접근은 일정한 시간으로 수행된다고 할 수 있다.

#### 장점

- 간단하고 사용하기 쉽다.
- 항목에의 접근이 더 빠르다(일정한 시간이 걸리는 접근).
- 연속된 메모리 블록으로 정의되므로 배열의 항목들은 물리적으로 근처에 위치한다. 이것은 현대의 CPU 캐싱 기법에 매우 유리하다.

#### 단점

- **고정된 크기**: 배열의 크기는 정적이다(사용하기 전에 배열의 크기를 지정해야 한다).
- **한 블록의 할당**: 처음에 배열을 할당할 때 전체 배열을 위한 메모리를 얻지 못할 때도 있다(배열크기가 클 경우).
- **복잡한 위치 기반의 삽입**: 주어진 위치에 항목을 삽입하려면 기존의 항목들을 이동해야 할 수 있다. 이렇게 해야 원하는 위치에 새 항목을 추가할 자리가 생긴다. 만약 새
  항목을
  추가할 자리가 가장 앞이면 다른 항목들의 이동 연산이 더욱 오래 걸리게 된다.

### 연결 리스트

일반적으로 '연결 리스트'는 단일 연결 리스트를 의미한다.

#### 연결 리스트의 장점

- 하나의 항목을 위한 공간으로 시작해서 복사나 재할당 없이 새 항목을 쉽게 추가할 수 있다.

#### 연결 리스트의 단점

- 개별 항목에 접근하는 시간이 길다.
- 때로 연결 리스트는 변경하기가 어렵다.
    - 마지막 항목이 삭제되면, 가장 끝에서 하나 전의 항목의 포인터가 null 을 가리키도록 변경되어야만 한다. 이 말은, 끝에서 하나 전의
      항목을 찾아 그 포인터가 null 을 가리키게 하기 위해 리스트가 탐색되어야 한다는 것이다.
- 추가적인 참조 포인터를 위한 메모리 공간이 낭비된다.

### 연결 리스트와 배열 그리고 동적 배열의 비교

| 항목          | 연결 리스트 | 배열   | 동적 배열                                         |
|-------------|--------|------|-----------------------------------------------|
| 인덱싱         | O(n)   | O(1) | O(1)                                          |
| 가장 앞에 추가/삭제 | O(1)   | -    | O(n)                                          |
| 가장 끝에 추가/삭제 | O(n)   | -    | 배열이 다 차지 않았을 경우에는 O(1)<br/> 배열이 다찾을 경우에는 O(n) |
| 중간에 추가/삭제   | O(n)   | -    | O(n)                                          |
| 낭비되는 공간     | O(n)   | 0    | O(n)                                          |

## Reference

- 다양한 예제로 학습하는 데이터 구조와 알고리즘 for Java